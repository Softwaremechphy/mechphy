#backend_logic/backendConnection/faust_app_v1.py
import faust
import json
import asyncio
from mode import Service
from websockets.server import WebSocketServerProtocol
from websockets.exceptions import ConnectionClosed
from db.schemas.incoming_soldier import Soldier
from db.data_transformer import transform_soldier_data
from db.mongodb_handler import store_to_mongo, get_soldier_data_from_db, get_soldier_data_from_latest_session, update_soldier_damage, get_db_in
from configs.config import settings
from configs.logging_config import faust_logger as logger
from datetime import datetime
from fastapi import FastAPI
from motor.motor_asyncio import AsyncIOMotorClient
import utils

app = FastAPI()
client = AsyncIOMotorClient(settings.MONGODB_URI)
db_in = client[settings.DB_in]

# WebSocket service for raw soldier data (port 8001)
class RawDataWebSocketService(Service):
    def __init__(self, app, bind: str = settings.WS_HOST, port: int = settings.WS_PORT, **kwargs):
        self.app = app
        self.bind = bind
        self.port = port
        self.connections = []
        super().__init__(**kwargs)

    # Define tasks for receiving and sending messages via WebSocket
    async def on_messages(self, websocket, path):
        self.connections.append(websocket)
        try:
            async for message in websocket:
                await self.on_message(websocket, message)
        except ConnectionClosed:
            self.connections.remove(websocket)

    async def on_message(self, websocket, message):
        await websocket.send(f"Received: {message}")

    @Service.task
    async def _background_server(self):
        import websockets
        await websockets.serve(self.on_messages, self.bind, self.port)

# WebSocket service for kill feed data (port 8002)
class KillFeedWebSocketService(Service):
    def __init__(self, app, bind: str = settings.WS_HOST, port: int = settings.KILL_FEED_WS_PORT, **kwargs):
        self.app = app
        self.bind = bind
        self.port = port
        self.connections = []
        super().__init__(**kwargs)

    # Define tasks for receiving and sending kill feed messages via WebSocket
    async def on_messages(self, websocket, path):
        self.connections.append(websocket)
        try:
            async for message in websocket:
                await self.on_message(websocket, message)
        except ConnectionClosed:
            self.connections.remove(websocket)

    async def on_message(self, websocket, message):
        await websocket.send(f"Received: {message}")

    @Service.task
    async def _background_server(self):
        import websockets
        await websockets.serve(self.on_messages, self.bind, self.port)


class TeamStatsWebSocketService(Service):
    def __init__(self, app, bind: str = settings.WS_HOST, port: int = 8003, **kwargs):
        self.app = app
        self.bind = bind
        self.port = port
        self.connections = []
        super().__init__(**kwargs)

    async def on_messages(self, websocket, path):
        self.connections.append(websocket)
        try:
            async for message in websocket:
                await self.on_message(websocket, message)
        except ConnectionClosed:
            self.connections.remove(websocket)

    async def on_message(self, websocket, message):
        await websocket.send(f"Received: {message}")

    @Service.task
    async def _background_server(self):
        import websockets
        await websockets.serve(self.on_messages, self.bind, self.port)


class App(faust.App):
    def on_init(self):
        self.ws_service_raw = RawDataWebSocketService(self, bind=settings.WS_HOST, port=8001)
        self.ws_service_kill_feed = KillFeedWebSocketService(self, bind=settings.WS_HOST, port=8002)
        self.ws_service_team_stats = TeamStatsWebSocketService(self, bind=settings.WS_HOST, port=8003)

    async def on_start(self):
        await self.add_runtime_dependency(self.ws_service_raw)
        await self.add_runtime_dependency(self.ws_service_kill_feed)
        await self.add_runtime_dependency(self.ws_service_team_stats)



## Define the Faust app
app = App(
    'soldiers-data',
    broker=settings.KAFKA_BROKER,
    store='memory://',
    value_serializer='json',
)

# Kafka topic to process incoming soldier data
soldier_topic = app.topic(settings.KAFKA_TOPIC, value_type=Soldier, partitions=1)

# Attach WebSocket services to Faust app
app.ws_service_raw = RawDataWebSocketService(app)
app.ws_service_kill_feed = KillFeedWebSocketService(app)
app.ws_service_team_stats = TeamStatsWebSocketService(app)


# Add function to calculate and broadcast team statistics
async def calculate_and_broadcast_team_stats(session_id):
    try:
        latest_session = await db_in["sessions"].find_one({"_id": session_id})
        if not latest_session:
            logger.error("No session found for team stats calculation")
            return

        # Initialize team stats
        team_stats = {
            "team_red": {"total_killed": 0, "bullets_fired": 0},
            "team_blue": {"total_killed": 0, "bullets_fired": 0}
        }

        # Calculate stats for each team
        for soldier in latest_session["participated_soldiers"]:
            team = soldier.get("team", "").lower()
            if team not in ["red", "blue"]:
                continue

            # Get latest stats for the soldier
            soldier_stats = soldier.get("stats", [])
            if soldier_stats:
                latest_stat = soldier_stats[-1]
                team_stats[f"team_{team}"]["total_killed"] += latest_stat.get("kill_count", 0)
                team_stats[f"team_{team}"]["bullets_fired"] += latest_stat.get("bullets_fired", 0)

        # Create current timestamp
        current_time = datetime.utcnow()

        # Create team stats event object
        team_stats_event = {
            "team_red": {
                "total_killed": team_stats["team_red"]["total_killed"],
                "bullets_fired": team_stats["team_red"]["bullets_fired"],
                "timestamp": current_time
            },
            "team_blue": {
                "total_killed": team_stats["team_blue"]["total_killed"],
                "bullets_fired": team_stats["team_blue"]["bullets_fired"],
                "timestamp": current_time
            }
        }

        # Store team stats in session history
        update_result = await db_in["sessions"].update_one(
            {"_id": session_id},
            {
                "$push": {
                    "team_stats_history": team_stats_event
                }
            }
        )

        if update_result.modified_count != 1:
            logger.error("Failed to store team stats in session history")

        # Prepare WebSocket message
        websocket_message = {
            "team_red": {
                "total_killed": team_stats["team_red"]["total_killed"],
                "bullets_fired": team_stats["team_red"]["bullets_fired"],
                "timestamp": current_time.isoformat()
            },
            "team_blue": {
                "total_killed": team_stats["team_blue"]["total_killed"],
                "bullets_fired": team_stats["team_blue"]["bullets_fired"],
                "timestamp": current_time.isoformat()
            }
        }

        # Broadcast team stats through WebSocket
        team_stats_message = json.dumps(websocket_message)
        for websocket in app.ws_service_team_stats.connections:
            await websocket.send(team_stats_message)

        logger.info(f"Team stats updated and broadcasted for session {session_id}")

    except Exception as e:
        logger.error(f"Error calculating team stats: {e}", exc_info=True)


@app.agent(soldier_topic)
async def process_soldiers(soldier_data_stream):
    bullet_counts = {}
    asyncio.create_task(periodic_stats_update(bullet_counts))
    
    async for soldier_data in soldier_data_stream:
        try:
            # Store the raw soldier data in MongoDB
            transformed_data = transform_soldier_data(soldier_data)
            transformed_data['timestamp'] = datetime.utcnow().isoformat()
            
            # Clear old data and update with new bullet count
            bullet_counts.clear()
            soldier_id = transformed_data['soldier_id']
            bullet_counts[str(soldier_id)] = transformed_data.get("bullet_count", 0)
            
            # Save to MongoDB (Reduntant for now and near future)
            await store_to_mongo(transformed_data)
            
            # Get latest session first
            latest_session = await db_in["sessions"].find_one(
                sort=[("start_time", -1)]
            )

            
            # Define new location object based on soldier_data
            new_location = {
                "latitude": transformed_data['gps']['latitude'],
                "longitude": transformed_data['gps']['longitude'],
                "timestamp": transformed_data['timestamp']
            }

            # Define new orientation object based on soldier_data
            new_orientation = {
                "roll": soldier_data.imu_data.roll,
                "pitch": soldier_data.imu_data.pitch,
                "yaw": soldier_data.imu_data.yaw,
                "timestamp": transformed_data['timestamp']
            }
            
            # Store location, orientation inside archival_monitoring/sessions_collection/participated_soldier['location'], participated_soldier['orientation']
            await db_in["sessions"].update_one(
                {"_id": latest_session["_id"], "participated_soldiers.soldier_id": transformed_data['soldier_id']},
                {
                    "$push": {
                        "participated_soldiers.$.location": new_location,
                        "participated_soldiers.$.orientation": new_orientation
                    }
                }
            )

            # Broadcast raw soldier data to WebSocket clients on port 8001
            raw_message = json.dumps(transformed_data)
            for websocket in app.ws_service_raw.connections:
                await websocket.send(raw_message)

            # Process the damage and kill feed logic
            if transformed_data['hit_status'] in [1, 2]:
                attacker_id = transformed_data['ammo']['attacker_id']
                victim_id = transformed_data['soldier_id']

                if not latest_session:
                    logger.error("No active session found")
                    continue

                # Fetch attacker and victim data from the latest session
                attacker_data = await get_soldier_data_from_latest_session(attacker_id)
                victim_data = await get_soldier_data_from_latest_session(victim_id)

                if not attacker_data or not victim_data:
                    logger.error(f"Soldier data not found for attacker: {attacker_id}, victim: {victim_id}")
                    continue

                is_soldier_killed = False
                
                # Handle hit_status == 1 (first hit takes to 50%, second hit kills)
                if transformed_data['hit_status'] == 1:
                    # Check if the victim's health is above 50%
                    victim_damage = victim_data.get('damage', {})
                    if '50' not in victim_damage:
                        # Drop health to 50% on the first hit
                        await update_soldier_damage(victim_id, 50)
                        logger.info(f"Updated health for soldier {victim_id} to 50%")
                    else:
                        # If already at 50%, mark as killed
                        await update_soldier_damage(victim_id, 100)
                        logger.info(f"Soldier {victim_id} marked as killed (health set to 100%)")
                        is_soldier_killed = True

                # Handle hit_status == 2 (direct death)
                elif transformed_data['hit_status'] == 2:
                    # Directly mark the soldier as killed
                    await update_soldier_damage(victim_id, 100)
                    logger.info(f"Soldier {victim_id} marked as killed (hit_status 2)")
                    is_soldier_killed = True

                # Only process kill feed and update stats if the soldier is actually killed
                if is_soldier_killed:
                    
                     # Calculated the distance
                    calculated_distance = await utils.calculate_distance_between_soldiers(attacker_id, victim_id)
                    # Create kill feed event with calculated distance
                    kill_event = {
                        "attacker_id": str(attacker_data['soldier_id']),
                        "attacker_call_sign": attacker_data['call_sign'],
                        "victim_id": str(victim_data['soldier_id']),
                        "victim_call_sign": victim_data['call_sign'],
                        "distance_to_victim (in meters)": calculated_distance,
                        "timestamp": transformed_data['timestamp'],
                    }

                    # Store kill event in session
                    update_result = await db_in["sessions"].update_one(
                        {"_id": latest_session["_id"]},
                        {
                            "$push": {
                                "events": kill_event
                            }
                        }
                    )

                    if update_result.modified_count != 1:
                        logger.error("Failed to store kill event in session")

                    # Broadcast kill feed message
                    kill_feed_message_json = json.dumps(kill_event)
                    for websocket in app.ws_service_kill_feed.connections:
                        await websocket.send(kill_feed_message_json)

                    # Update attacker's stats
                    try:
                        attacker_index = next(
                            (index for (index, soldier) in enumerate(latest_session["participated_soldiers"])
                            if soldier["soldier_id"] == str(attacker_id)),
                            None
                        )

                        if attacker_index is not None:
                            current_stats = latest_session["participated_soldiers"][attacker_index].get("stats", [])
                            current_kills = current_stats[-1].get("kill_count", 0) if current_stats else 0

                            new_stat = {
                                "kill_count": current_kills + 1,
                                "bullets_fired": transformed_data.get("bullet_count", 0),
                                "timestamp": datetime.utcnow().isoformat()
                            }

                            update_result = await db_in["sessions"].update_one(
                                {"_id": latest_session["_id"]},
                                {
                                    "$push": {
                                        f"participated_soldiers.{attacker_index}.stats": new_stat
                                    }
                                }
                            )

                            if update_result.modified_count != 1:
                                logger.error(f"Failed to update stats for attacker {attacker_id}")
                                
                            # Calculate and broadcast team stats after kill
                            await calculate_and_broadcast_team_stats(latest_session["_id"])

                    except Exception as e:
                        logger.error(f"Error updating attacker stats: {e}", exc_info=True)

            logger.info(f"Processed soldier data: {transformed_data}")

        except Exception as e:
            logger.error(f"Error processing soldier data: {e}", exc_info=True)


# Regular async function (not a Kafka consumer)
async def periodic_stats_update(bullet_counts):
    while True:
        try:
            # Wait for 5 seconds
            await asyncio.sleep(5)
            
            latest_session = await db_in["sessions"].find_one(
                sort=[("start_time", -1)]
            )

            if not latest_session:
                logger.error("No active session found for periodic update")
                continue

            # Update stats for each soldier
            for soldier_index, soldier in enumerate(latest_session["participated_soldiers"]):
                try:
                    soldier_id = soldier["soldier_id"]
                    current_stats = soldier.get("stats", [])
                    if not current_stats:
                        continue

                    latest_kill_count = current_stats[-1].get("kill_count", 0)
                    latest_bullet_count = bullet_counts.get(str(soldier_id), 0)

                    new_stat = {
                        "kill_count": latest_kill_count,
                        "bullets_fired": latest_bullet_count,
                        "timestamp": datetime.utcnow().isoformat()
                    }

                    update_result = await db_in["sessions"].update_one(
                        {"_id": latest_session["_id"]},
                        {
                            "$push": {
                                f"participated_soldiers.{soldier_index}.stats": new_stat
                            }
                        }
                    )

                    if update_result.modified_count == 1:
                        logger.info(f"Successfully updated periodic stats for soldier {soldier_id}")
                    else:
                        logger.error(f"Failed to update periodic stats for soldier {soldier_id}")

                except Exception as e:
                    logger.error(f"Error updating periodic stats for soldier {soldier_id}: {e}", exc_info=True)

            # Calculate and broadcast team stats after updating all soldiers
            await calculate_and_broadcast_team_stats(latest_session["_id"])
            
        except Exception as e:
            logger.error(f"Error in periodic stats update: {e}", exc_info=True)
            await asyncio.sleep(1)


if __name__ == "__main__":
    app.main()
