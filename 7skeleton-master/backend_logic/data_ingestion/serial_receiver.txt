# #backend_logic/data_ingestion/serial_receiver.py
# import serial
# import asyncio
# import signal
# from faust import Record

# # Faust record classes
# class GPSData(Record):
#     latitude: float
#     longitude: float

# class IMUData(Record):
#     roll: float
#     pitch: float
#     yaw: float

# class HitData(Record):
#     is_hit: bool

# class AmmoData(Record):
#     attacker_id: int
#     fire_mode: int
#     weapon_id: int

# class SoldierData(Record):
#     soldier_id: str
#     gps_data: GPSData
#     imu_data: IMUData
#     hit_data: HitData
#     ammo_data: AmmoData
#     weapon_id: int
#     fire_mode: int
#     trigger_event: int
#     bullet_count: int

# # Function to parse raw CSV data
# def parse_raw_data(raw_data: str) -> SoldierData:
#     try:
#         data = raw_data.split(',')
#         soldier_id = data[0]
#         latitude = float(data[1])
#         longitude = float(data[2])
#         roll = float(data[3])
#         pitch = float(data[4])
#         yaw = float(data[5])
#         is_hit = bool(int(data[6]))
#         attacker_id = int(data[7])
#         fire_mode = int(data[8])
#         weapon_id = int(data[9])
#         trigger_event = int(data[10])
#         bullet_count = int(data[11])

#         soldier_data = SoldierData(
#             soldier_id=soldier_id,
#             gps_data=GPSData(latitude=latitude, longitude=longitude),
#             imu_data=IMUData(
#                 roll=roll,
#                 pitch=pitch,
#                 yaw=yaw
#             ),
#             hit_data=HitData(is_hit=is_hit),
#             ammo_data=AmmoData(
#                 attacker_id=attacker_id,
#                 fire_mode=fire_mode,
#                 weapon_id=weapon_id
#             ),
#             weapon_id=weapon_id,
#             fire_mode=fire_mode,
#             trigger_event=trigger_event,
#             bullet_count = bullet_count
#         )
#         return soldier_data
#     except (IndexError, ValueError) as e:
#         print(f"Error parsing data: {e}")
#         return None

# # Async function to receive data from the serial port
# async def receive_serial_data():
#     ser = None
#     while True:
#         try:
#             # Try to establish a serial connection
#             ser = serial.Serial('/dev/ttyUSB1', 9600)
#             print(f"Connected to {'/dev/ttyUSB1'} at {9600} baud")

#             while True:
#                 if ser.in_waiting > 0:
#                     raw_data = ser.readline().decode('utf-8').strip()
#                     print(f"Received raw data: {raw_data}")
                    
#                     # Parse the raw data into SoldierData object
#                     soldier_data = parse_raw_data(raw_data)
                    
#                     if soldier_data:
#                         print(f"Parsed Soldier Data: {soldier_data}")
#                         yield soldier_data  # Yield parsed soldier data asynchronously
#                     else:
#                         print("Failed to parse raw data.")
                    
#                 await asyncio.sleep(0.1)

#         except serial.SerialException as e:
#             print(f"Serial communication error: {e}")
#             if ser and ser.is_open:
#                 ser.close()  # Ensure the connection is closed
#             print("Attempting to reconnect in 5 seconds...")
#             await asyncio.sleep(5)  # Wait before retrying the connection
#         except Exception as e:
#             print(f"Unexpected error: {e}")
#             if ser and ser.is_open:
#                 ser.close()
#             print("Communication error")
#             print("Check Your communication")
#             await asyncio.sleep(5)  # Wait before retrying on general errors

#         finally:
#             if ser and ser.is_open:
#                 print("Closing serial connection.")
#                 ser.close()



# import serial
# import re

# class GPSData:
#     def __init__(self, latitude, longitude):
#         self.latitude = latitude
#         self.longitude = longitude

# class IMUData:
#     def __init__(self, roll, pitch, yaw):
#         self.roll = roll
#         self.pitch = pitch
#         self.yaw = yaw

# class HitData:
#     def __init__(self, hit_status):
#         self.hit_status = hit_status

# class AmmoData:
#     def __init__(self, attacker_id, fire_mode, weapon_id):
#         self.attacker_id = attacker_id
#         self.fire_mode = fire_mode
#         self.weapon_id = weapon_id

# class SoldierData:
#     def __init__(self, soldier_id, gps_data, imu_data, hit_data, ammo_data, weapon_id, fire_mode, trigger_event, bullet_count):
#         self.soldier_id = soldier_id
#         self.gps_data = gps_data
#         self.imu_data = imu_data
#         self.hit_data = hit_data
#         self.ammo_data = ammo_data
#         self.weapon_id = weapon_id
#         self.fire_mode = fire_mode
#         self.trigger_event = trigger_event
#         self.bullet_count = bullet_count

# def parse_raw_data(raw_data: str) -> SoldierData:
#     """Parse a single message and convert lat/long to decimal degrees."""
#     try:
#         # Split the comma-separated values
#         data = raw_data.split(',')
#         if len(data) != 12:
#             print(f"Invalid data length: {raw_data}")
#             return None

#         # Extract fields
#         soldier_id = data[0]

#         # Convert latitude from DDMM.MMMM to decimal degrees
#         lat = float(data[1])  # e.g., 2831.50527
#         lat_deg = int(lat / 100)  # 28
#         lat_min = lat - (lat_deg * 100)  # 31.50527
#         latitude = lat_deg + (lat_min / 60)  # 28 + 31.50527/60

#         # Convert longitude from DDDMM.MMMM to decimal degrees
#         lon = float(data[2])  # e.g., 07716.95995
#         lon_deg = int(lon / 100)  # 77
#         lon_min = lon - (lon_deg * 100)  # 16.95995
#         longitude = lon_deg + (lon_min / 60)  # 77 + 16.95995/60

#         # Parse remaining fields
#         roll = float(data[3])
#         pitch = float(data[4])
#         yaw = float(data[5])
#         hit_status = int(data[6])
#         attacker_id = data[7]  # Kept as string
#         fire_mode = int(data[8])
#         weapon_id = int(data[9])
#         trigger_event = int(data[10])
#         bullet_count = int(data[11])

#         # Create SoldierData object
#         soldier_data = SoldierData(
#             soldier_id=soldier_id,
#             gps_data=GPSData(latitude=latitude, longitude=longitude),
#             imu_data=IMUData(roll=roll, pitch=pitch, yaw=yaw),
#             hit_data=HitData(hit_status=hit_status),
#             ammo_data=AmmoData(attacker_id=attacker_id, fire_mode=fire_mode, weapon_id=weapon_id),
#             weapon_id=weapon_id,
#             fire_mode=fire_mode,
#             trigger_event=trigger_event,
#             bullet_count=bullet_count
#         )
#         return soldier_data

#     except Exception as e:
#         print(f"Error parsing data: {e}")
#         return None

# def receive_serial_data():
#     """Read and process serial data in the new format."""
#     ser = serial.Serial('/dev/ttyUSB1', 9600, timeout=1)
#     buffer = ""

#     print("Connected to /dev/ttyUSB1 at 9600 baud")
#     while True:
#         try:
#             # Read a chunk of data (e.g., 1024 bytes)
#             data = ser.read(1024).decode('utf-8')
#             if data:
#                 buffer += data
#                 print(f"Received raw data: {data}")

#                 # Extract all complete messages within {}
#                 messages = re.findall(r'\{(.*?)\}', buffer)
#                 for msg in messages:
#                     soldier_data = parse_raw_data(msg)
#                     if soldier_data:
#                         print(f"Parsed SoldierData: soldier_id={soldier_data.soldier_id}, "
#                               f"lat={soldier_data.gps_data.latitude:.6f}, "
#                               f"lon={soldier_data.gps_data.longitude:.6f}")

#                 # Remove processed messages from the buffer
#                 last_brace = buffer.rfind('}')
#                 if last_brace != -1:
#                     buffer = buffer[last_brace + 1:]

#         except Exception as e:
#             print(f"Error reading serial data: {e}")

# if __name__ == "__main__":
#     receive_serial_data()


import aioserial
import asyncio
import re
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

class GPSData:
    def __init__(self, latitude, longitude):
        self.latitude = latitude
        self.longitude = longitude

class IMUData:
    def __init__(self, roll, pitch, yaw):
        self.roll = roll
        self.pitch = pitch
        self.yaw = yaw

class HitData:
    def __init__(self, hit_status):
        self.hit_status = hit_status

class AmmoData:
    def __init__(self, attacker_id, fire_mode, weapon_id):
        self.attacker_id = attacker_id
        self.fire_mode = fire_mode
        self.weapon_id = weapon_id

class SoldierData:
    def __init__(self, soldier_id, gps_data, imu_data, hit_data, ammo_data, weapon_id, fire_mode, trigger_event, bullet_count):
        self.soldier_id = soldier_id
        self.gps_data = gps_data
        self.imu_data = imu_data
        self.hit_data = hit_data
        self.ammo_data = ammo_data
        self.weapon_id = weapon_id
        self.fire_mode = fire_mode
        self.trigger_event = trigger_event
        self.bullet_count = bullet_count
    
    def to_dict(self):
        """Convert SoldierData to a dictionary compatible with Faust's Soldier record."""
        return {
            "soldier_id": self.soldier_id,
            "gps_data": {"latitude": self.gps_data.latitude, "longitude": self.gps_data.longitude},
            "imu_data": {"roll": self.imu_data.roll, "pitch": self.imu_data.pitch, "yaw": self.imu_data.yaw},
            "hit_data": {"hit_status": self.hit_data.hit_status},
            "ammo_data": {
                "attacker_id": self.ammo_data.attacker_id,
                "fire_mode": self.ammo_data.fire_mode,
                "weapon_id": self.ammo_data.weapon_id
            },
            "weapon_id": self.weapon_id,
            "fire_mode": self.fire_mode,
            "trigger_event": self.trigger_event,
            "bullet_count": self.bullet_count
        }
    
    def __repr__(self):
        return (f"SoldierData(soldier_id={self.soldier_id}, "
                f"latitude={self.gps_data.latitude:.6f}, "
                f"longitude={self.gps_data.longitude:.6f}, "
                f"roll={self.imu_data.roll}, "
                f"pitch={self.imu_data.pitch}, "
                f"yaw={self.imu_data.yaw}, "
                f"hit_status={self.hit_data.hit_status}, "
                f"attacker_id={self.ammo_data.attacker_id}, "
                f"fire_mode={self.fire_mode}, "
                f"weapon_id={self.weapon_id}, "
                f"trigger_event={self.trigger_event}, "
                f"bullet_count={self.bullet_count})")

async def parse_raw_data(raw_data: str) -> SoldierData:
    """Parse a single message and convert lat/long to decimal degrees."""
    try:
        logger.debug(f"Parsing raw data: {raw_data}")
        # Remove braces and split by commas
        data = raw_data.strip('{}').split(',')
        if len(data) != 12:
            logger.warning(f"Invalid data length: {len(data)} fields in {raw_data}")
            return None

        # Extract fields
        soldier_id = data[0]

        # Convert latitude from DDMM.MMMM to decimal degrees
        lat = float(data[1])  # e.g., 2831.50628
        lat_deg = int(lat / 100)  # 28
        lat_min = lat - (lat_deg * 100)  # 31.50628
        latitude = lat_deg + (lat_min / 60)  # 28 + 31.50628/60

        # Convert longitude from DDDMM.MMMM to decimal degrees
        lon = float(data[2])  # e.g., 07716.95989
        lon_deg = int(lon / 100)  # 77
        lon_min = lon - (lon_deg * 100)  # 16.95989
        longitude = lon_deg + (lon_min / 60)  # 77 + 16.95989/60

        # Parse remaining fields
        roll = float(data[3])
        pitch = float(data[4])
        yaw = float(data[5])
        hit_status = int(data[6])
        attacker_id = data[7]  # Kept as string
        fire_mode = int(data[8])
        weapon_id = int(data[9])
        trigger_event = int(data[10])
        bullet_count = int(data[11])

        # Create SoldierData object
        soldier_data = SoldierData(
            soldier_id=soldier_id,
            gps_data=GPSData(latitude=latitude, longitude=longitude),
            imu_data=IMUData(roll=roll, pitch=pitch, yaw=yaw),
            hit_data=HitData(hit_status=hit_status),
            ammo_data=AmmoData(attacker_id=attacker_id, fire_mode=fire_mode, weapon_id=weapon_id),
            weapon_id=weapon_id,
            fire_mode=fire_mode,
            trigger_event=trigger_event,
            bullet_count=bullet_count
        )
        logger.info(f"Successfully parsed: {soldier_data}")
        return soldier_data

    except Exception as e:
        logger.error(f"Error parsing data: {raw_data}, Error: {e}")
        return None
            
# Repeating receive_serial_data to solve a bug on 2/06/25
async def receive_serial_data():
    """Asynchronously read and process serial data using aioserial."""
    while True:
        ser = None
        try:
            ser = aioserial.AioSerial(port='/dev/ttyUSB0', baudrate=9600, timeout=1)
            logger.info(f"Connected to {ser.port} at {ser.baudrate} baud")
            buffer = ""
            
            while True:
                # Read up to 1024 bytes asynchronously
                data = await ser.read_async(1024)
                if data:
                    raw_data = data.decode('utf-8', errors='ignore').strip()
                    logger.debug(f"Raw data received: {raw_data}")
                    buffer += raw_data
                    
                    # Extract all complete messages within {}
                    messages = re.findall(r'\{(.*?)\}', buffer)
                    for msg in messages:
                        soldier_data = await parse_raw_data(msg)
                        if soldier_data:
                            logger.info(f"Yielding parsed data: {soldier_data}")
                            yield soldier_data.to_dict()  # Yield dictionary for Faust
                    
                    # Remove processed messages from buffer
                    last_brace = buffer.rfind('}')
                    if last_brace != -1:
                        buffer = buffer[last_brace + 1:]
                else:
                    logger.debug("No data received in this iteration")
                    await asyncio.sleep(0.1)  # Prevent tight loop
                
        except Exception as e:
            logger.error(f"Serial communication error: {e}")
            await asyncio.sleep(5)  # Wait before retrying
        finally:
            if ser and ser.is_open:
                logger.info("Closing serial connection")
                ser.close()

if __name__ == "__main__":
    asyncio.run(receive_serial_data())
    
    

# async def receive_serial_data():
#     """Asynchronously read and process serial data using aioserial."""
#     ser = None
#     try:
#         ser = aioserial.AioSerial(port='/dev/ttyUSB0', baudrate=9600, timeout=1)
#         logger.info(f"Connected to {ser.port} at {ser.baudrate} baud")
#         buffer = ""
        
#         while True:
#             # Read up to 1024 bytes asynchronously
#             data = await ser.read_async(1024)
#             if data:
#                 raw_data = data.decode('utf-8', errors='ignore').strip()
#                 logger.debug(f"Raw data received: {raw_data}")
#                 buffer += raw_data
                
#                 # Extract all complete messages within {}
#                 messages = re.findall(r'\{(.*?)\}', buffer)
#                 for msg in messages:
#                     soldier_data = await parse_raw_data(msg)
#                     if soldier_data:
#                         logger.info(f"Yielding parsed data: {soldier_data}")
#                         yield soldier_data.to_dict()  # Yield dictionary for Faust
                
#                 # Remove processed messages from buffer
#                 last_brace = buffer.rfind('}')
#                 if last_brace != -1:
#                     buffer = buffer[last_brace + 1:]
#             else:
#                 logger.debug("No data received in this iteration")
#                 await asyncio.sleep(0.1)  # Prevent tight loop
            
#     except Exception as e:
#         logger.error(f"Serial communication error: {e}")
#         await asyncio.sleep(5)  # Wait before retrying
#     finally:
#         if ser and ser.is_open:
#             logger.info("Closing serial connection")
#             ser.close()









// different code for mesh waali bkc
import aioserial
import asyncio
import re
import logging

# Configure logging
logging.basicConfig(level=logging.DEBUG)
logger = logging.getLogger(__name__)

class GPSData:
    def __init__(self, latitude, longitude):
        self.latitude = latitude
        self.longitude = longitude

class IMUData:
    def __init__(self, roll, pitch, yaw):
        self.roll = roll
        self.pitch = pitch
        self.yaw = yaw

class HitData:
    def __init__(self, hit_status):
        self.hit_status = hit_status

class AmmoData:
    def __init__(self, attacker_id, fire_mode, weapon_id):
        self.attacker_id = attacker_id
        self.fire_mode = fire_mode
        self.weapon_id = weapon_id

class SoldierData:
    def __init__(self, soldier_id, gps_data, imu_data, hit_data, ammo_data, weapon_id, fire_mode, trigger_event, bullet_count):
        self.soldier_id = soldier_id
        self.gps_data = gps_data
        self.imu_data = imu_data
        self.hit_data = hit_data
        self.ammo_data = ammo_data
        self.weapon_id = weapon_id
        self.fire_mode = fire_mode
        self.trigger_event = trigger_event
        self.bullet_count = bullet_count
    
    def to_dict(self):
        """Convert SoldierData to a dictionary compatible with Faust's Soldier record."""
        return {
            "soldier_id": self.soldier_id,
            "gps_data": {"latitude": self.gps_data.latitude, "longitude": self.gps_data.longitude},
            "imu_data": {"roll": self.imu_data.roll, "pitch": self.imu_data.pitch, "yaw": self.imu_data.yaw},
            "hit_data": {"hit_status": self.hit_data.hit_status},
            "ammo_data": {
                "attacker_id": self.ammo_data.attacker_id,
                "fire_mode": self.ammo_data.fire_mode,
                "weapon_id": self.ammo_data.weapon_id
            },
            "weapon_id": self.weapon_id,
            "fire_mode": self.fire_mode,
            "trigger_event": self.trigger_event,
            "bullet_count": self.bullet_count
        }
    
    def __repr__(self):
        return (f"SoldierData(soldier_id={self.soldier_id}, "
                f"latitude={self.gps_data.latitude:.6f}, "
                f"longitude={self.gps_data.longitude:.6f}, "
                f"roll={self.imu_data.roll}, "
                f"pitch={self.imu_data.pitch}, "
                f"yaw={self.imu_data.yaw}, "
                f"hit_status={self.hit_data.hit_status}, "
                f"attacker_id={self.ammo_data.attacker_id}, "
                f"fire_mode={self.fire_mode}, "
                f"weapon_id={self.weapon_id}, "
                f"trigger_event={self.trigger_event}, "
                f"bullet_count={self.bullet_count})")

async def parse_raw_data(raw_data: str) -> SoldierData:
    """Parse a single message and convert lat/long to decimal degrees."""
    try:
        logger.debug(f"Parsing raw data: {raw_data}")
        # Split by commas
        data = raw_data.split(',')
        if len(data) != 12:
            logger.warning(f"Invalid data length: {len(data)} fields in {raw_data}")
            return None

        # Extract fields
        soldier_id = data[0]

        # Convert latitude from DDMM.MMMM to decimal degrees
        lat = float(data[1])  # e.g., 2831.51770
        lat_deg = int(lat / 100)  # 28
        lat_min = lat - (lat_deg * 100)  # 31.51770
        latitude = lat_deg + (lat_min / 60)  # 28 + 31.51770/60

        # Convert longitude from DDDMM.MMMM to decimal degrees
        lon = float(data[2])  # e.g., 07716.94183
        lon_deg = int(lon / 100)  # 77
        lon_min = lon - (lon_deg * 100)  # 16.94183
        longitude = lon_deg + (lon_min / 60)  # 77 + 16.94183/60

        # Parse remaining fields - these appear to be IMU data now
        roll = float(data[3])    # 1183.0
        pitch = float(data[4])   # -332.0
        yaw = float(data[5])     # -93.0
        hit_status = int(data[6])
        attacker_id = data[7]  # Kept as string
        fire_mode = int(data[8])
        weapon_id = int(data[9])
        trigger_event = int(data[10])
        bullet_count = int(data[11])

        # Create SoldierData object
        soldier_data = SoldierData(
            soldier_id=soldier_id,
            gps_data=GPSData(latitude=latitude, longitude=longitude),
            imu_data=IMUData(roll=roll, pitch=pitch, yaw=yaw),
            hit_data=HitData(hit_status=hit_status),
            ammo_data=AmmoData(attacker_id=attacker_id, fire_mode=fire_mode, weapon_id=weapon_id),
            weapon_id=weapon_id,
            fire_mode=fire_mode,
            trigger_event=trigger_event,
            bullet_count=bullet_count
        )
        logger.info(f"Successfully parsed: {soldier_data}")
        return soldier_data

    except Exception as e:
        logger.error(f"Error parsing data: {raw_data}, Error: {e}")
        return None

async def receive_serial_data():
    """Asynchronously read and process serial data using aioserial."""
    while True:
        ser = None
        try:
            ser = aioserial.AioSerial(port='/dev/ttyUSB0', baudrate=9600, timeout=1)
            logger.info(f"Connected to {ser.port} at {ser.baudrate} baud")
            buffer = ""
            
            while True:
                # Read up to 1024 bytes asynchronously
                data = await ser.read_async(1024)
                if data:
                    # Decode with error handling for noisy data
                    raw_data = data.decode('utf-8', errors='ignore').strip()
                    logger.debug(f"Raw data received: {repr(raw_data)}")
                    
                    # Add to buffer and normalize line endings
                    buffer += raw_data.replace('\r\n', '\n').replace('\r', '\n')
                    
                    # Extract all complete messages within {}
                    messages = re.findall(r'\{([^{}]*)\}', buffer)
                    
                    for msg in messages:
                        logger.debug(f"Extracted message: {msg}")
                        soldier_data = await parse_raw_data(msg)
                        if soldier_data:
                            logger.info(f"Yielding parsed data: {soldier_data}")
                            yield soldier_data.to_dict()  # Yield dictionary for Faust
                    
                    # Remove processed messages from buffer
                    last_brace = buffer.rfind('}')
                    if last_brace != -1:
                        buffer = buffer[last_brace + 1:]
                    
                    # Prevent buffer from growing too large with protocol noise
                    if len(buffer) > 2048:
                        logger.warning("Buffer too large, clearing to prevent memory issues")
                        buffer = buffer[-512:]  # Keep only the last 512 characters
                        
                else:
                    logger.debug("No data received in this iteration")
                    await asyncio.sleep(0.1)  # Prevent tight loop
                
        except Exception as e:
            logger.error(f"Serial communication error: {e}")
            await asyncio.sleep(5)  # Wait before retrying
        finally:
            if ser and ser.is_open:
                logger.info("Closing serial connection")
                ser.close()

# Test function to validate parsing with your sample data
async def test_parsing():
    """Test the parsing function with sample data."""
    test_data = "5,2831.51770,07716.94183,1183.0,-332.0,-93.0,0,0,0,0,0,0"
    result = await parse_raw_data(test_data)
    if result:
        print(f"Test successful: {result}")
    else:
        print("Test failed")

if __name__ == "__main__":
    # Uncomment the line below to test parsing
    # asyncio.run(test_parsing())
    
    # Run the main serial receiver
    asyncio.run(receive_serial_data())